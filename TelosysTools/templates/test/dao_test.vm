/*
 * Created on $today.date ( Time $today.time )
 * Generated by $generator.name ( version $generator.version )
 */
#set( $entityDaoClass = "${entity.name}Dao" )
#set( $entityMockClass        = "${entity.name}Mock" )
#set( $dataFields = $entity.getAttributesByCriteria( $const.NOT_KEY, $const.NOT_IN_SELECTED_LINKS ) )
## TODO : $template.requiredVariable('ROOT_PKG')
package ${target.javaPackageFromFolder($TEST_SRC)};

import java.util.List;

import org.apache.commons.lang3.StringUtils;
import org.hamcrest.Matchers;
import org.junit.Assert;
import org.junit.Before;
import org.junit.Test;
import org.springframework.beans.factory.annotation.Autowired;


import ${ROOT_PKG}.${entity.name.toLowerCase()}.dao.${entity.name}Dao;
import ${ROOT_PKG}.${entity.name.toLowerCase()}.dto.${entity.name}Dto;
import ${ROOT_PKG}.${entity.name.toLowerCase()}.model.${entity.name};
import com.temperies.dto.Sort;
import com.temperies.mock.tool.MockValues;
import com.temperies.test.AbstractTestWithContext;

public class ${entity.name}DaoTest extends AbstractTestWithContext {

	@Autowired
	${entity.name}Dao ${entity.name.toLowerCase()}Dao;

	@Before
	public void setup() {
		for (${entity.name} e : ${entity.name.toLowerCase()}Dao.findAll()) {
			${entity.name.toLowerCase()}Dao.delete(e);
		}
	}

	@Test
	public void testAllDaoMethods() {
		// * A first find all to get all the objects from the database
		int initialCount = ${entity.name.toLowerCase()}Dao.findAll().size();
		Assert.assertThat("first find all", initialCount, Matchers.is(0));
		// * Create an object with random values and persist it into the
		// database
		${entity.name} entity = ${entity.name}Mock.createInstance();
		${entity.name.toLowerCase()}Dao.saveOrUpdate(entity);
		Assert.assertThat("object is saved and id is assigned", entity.getId(),
				Matchers.notNullValue());
		// * Find the created object from the database
		${entity.name} foundEntity = ${entity.name.toLowerCase()}Dao.findOne(entity.getId());
		Assert.assertThat("Find the created object from the database",
				foundEntity, Matchers.notNullValue());
		// * Make sure it exists
		// * Make sure it has the right random values
		Assert.assertThat("Make sure it has the right random values",
				foundEntity, Matchers.equalTo(entity));
		// * Update the created object with other random values into the
		// database
		entity.setName(new MockValues().nextString(30));
		${entity.name.toLowerCase()}Dao.saveOrUpdate(entity);
		int actualCount = ${entity.name.toLowerCase()}Dao.findAll().size();
		Assert.assertThat(
				"Makes sure that there is one more object in the DataBase",
				actualCount, Matchers.equalTo(initialCount + 1));
		// * Find the updated object from the database
		foundEntity = ${entity.name.toLowerCase()}Dao.findOne(entity.getId());
		Assert.assertThat("Find the updated object from the database",
				foundEntity, Matchers.notNullValue());
		// * Make sure it still exists
		// * Make sure it has the new random values
		Assert.assertThat("Make sure it has the new random values",
				foundEntity, Matchers.equalTo(entity));
		// * A second find all A second find all makes sure that there is one
		// more object in the
		// database
		// * Delete the object from the database
		${entity.name.toLowerCase()}Dao.deleteById(entity.getId());
		// * Find the object from the database
		// * Make sure it doesn�t exist
		foundEntity = ${entity.name.toLowerCase()}Dao.findOne(entity.getId());
		Assert.assertThat(
				"Delete the object from the database, Make sure it doesn�t exist",
				foundEntity, Matchers.nullValue());
		// * A third find all makes sure that there is the initial number of
		// objects in the database
		actualCount = ${entity.name.toLowerCase()}Dao.findAll().size();
		Assert.assertThat(
				"Makes sure that there is the initial number of objects in the database",
				actualCount, Matchers.equalTo(initialCount));
	}

	@Test
	public void testPagination() {
		List<${entity.name}> list = ${entity.name}Mock.createList(50);
		for (${entity.name} e : list) {
			${entity.name.toLowerCase()}Dao.saveOrUpdate(e);
		}
		int maxResults = 20;
		${entity.name}Dto dto = new ${entity.name}Dto();
		dto.setLimit(maxResults);
		List<${entity.name}> result = ${entity.name.toLowerCase()}Dao.find(dto);
		Assert.assertThat("Pagination result has right size", result,
				Matchers.hasSize(maxResults));

		maxResults = 30;
		dto.setLimit(maxResults);
		result = ${entity.name.toLowerCase()}Dao.find(dto);
		Assert.assertThat("Pagination result has right size", result,
				Matchers.hasSize(maxResults));

		maxResults = 60;
		dto.setLimit(maxResults);
		result = ${entity.name.toLowerCase()}Dao.find(dto);
		Assert.assertThat("Pagination result has right size", result,
				Matchers.hasSize(50));

		
		// Test Pages
		dto.setStart(0);
		dto.setLimit(20);
		result = ${entity.name.toLowerCase()}Dao.find(dto);
		Assert.assertThat(result, Matchers.hasSize(20));

		dto.setStart(20);
		result = ${entity.name.toLowerCase()}Dao.find(dto);
		Assert.assertThat(result, Matchers.hasSize(20));

		dto.setStart(40);
		result = ${entity.name.toLowerCase()}Dao.find(dto);
		Assert.assertThat("Last page has 10 elements", result,
				Matchers.hasSize(10));
	}
	@Test
	public void testSort() {
		List<${entity.name}> list = ${entity.name}Mock.createList(50);
		for (${entity.name} e : list) {
			${entity.name.toLowerCase()}Dao.saveOrUpdate(e);
		}
		${entity.name}Dto dto = new ${entity.name}Dto();
		// Check Order
		Sort sort = new Sort();
#foreach( $field in $entity.keyAttributes )
	//$field.name
#end
		sort.setProperty("name");
		sort.setDirection("ASC");
		dto.addSort(sort);

		List<${entity.name}> result = ${entity.name.toLowerCase()}Dao.find(dto);

		String prevName = "";
		for (${entity.name} a : result) {
			if (StringUtils.isNotEmpty(prevName)) {
				String message = String.format("%s precedes %s", prevName,
						a.getName());
				Assert.assertThat(message, prevName.compareTo(a.getName()),
						Matchers.lessThanOrEqualTo(0));
			}
			prevName = a.getName();
		}

		sort.setDirection("DESC");
		dto.addSort(sort);
		result = ${entity.name.toLowerCase()}Dao.find(dto);
		prevName = "";
		for (${entity.name} a : result) {
			if (StringUtils.isNotEmpty(prevName)) {
				String message = String.format("%s follows  %s", prevName,
						a.getName());
				Assert.assertThat(message, prevName.compareTo(a.getName()),
						Matchers.greaterThanOrEqualTo(0));
			}
			prevName = a.getName();
		}
	}
@Test
	public void testGetOrCreate() throws Exception {
		${entity.name} ent = ${entity.name.toLowerCase()}Dao.findAll().get(0);

		${entity.name} found = ${entity.name.toLowerCase()}Dao.getOrCreate(ent, "name");
		Assert.assertNotNull(found);

		${entity.name} new${entity.name} = ${entity.name}Mock
				.createInstance();

		${entity.name} newfound = ${entity.name.toLowerCase()}Dao.getOrCreate(
				new${entity.name}, "name");
		Assert.assertNotNull(newfound);
		Assert.assertNotNull(newfound.getId());

	}

	@Test
	public void testGetOrCreateWithId() throws Exception {
		${entity.name} ent = new ${entity.name}();
		ent.setId(1);

		${entity.name} found = ${entity.name.toLowerCase()}Dao.getOrCreate(ent, "name");
		Assert.assertNotNull(found);
		Assert.assertNotNull(found.getId());

	}

	@Test
	public void testGetOrCreateWithNull() throws Exception {
		${entity.name} ent = new ${entity.name}();

		${entity.name} found = ${entity.name.toLowerCase()}Dao.getOrCreate(ent, "name");
		Assert.assertNull(found);

	}

}
